---
/* pages > posts > [...slug].astro에서 가져온 headings */
const { headings } = Astro.props;
---

<aside id="toc" class="sticky top-[95px] z-[100] max-[1300px]:hidden" aria-label="목차">
	<div class="tocInner">
		<ul class="flex flex-col">
			{
				headings?.map((h) => (
					<li class={`!leading-[18px] mb-4 text-sm tocDepth${h.depth}`}>
						<a class="tocLink" href={`#${h.slug}`} title={h.text}>
							{h.text}
						</a>
					</li>
				))
			}
		</ul>
	</div>
</aside>

<script>
	// @ts-nocheck
	(() => {
		const articleInner = document.querySelector('.articleInner');
		const tocInner = document.querySelector('.tocInner');

		if (!articleInner || !tocInner) return;

		const ACTIVATION_MARGIN = 10;
		const tags = Array.from(articleInner.querySelectorAll('h2, h3, h4'));
		const tocItems = Array.from(tocInner.querySelectorAll('.tocLink'));
		const header = document.querySelector('#header');

		// 개수 불일치/없음 방어
		if (!tags.length || !tocItems.length) return;

		tags.forEach((heading) => heading.classList.add('heading'));
		tocItems.forEach((item, index) => (item.dataset.index = String(index)));

		let selectedIndex = -1;
		let headingTops = [];

		const getHeaderOffset = () => {
			if (!header) return ACTIVATION_MARGIN;
			return Math.round(header.getBoundingClientRect().height) + ACTIVATION_MARGIN;
		};

		const measureHeadingTops = () => {
			headingTops = tags.map((tag) => {
				const rect = tag.getBoundingClientRect();
				return Math.round(window.scrollY + rect.top);
			});
		};

		const keepActiveItemVisible = () => {
			if (selectedIndex < 0) return;

			const selectedItem = tocItems[selectedIndex];
			if (!selectedItem) return;

			const itemTop = selectedItem.offsetTop;
			const itemBottom = itemTop + selectedItem.offsetHeight;
			const viewTop = tocInner.scrollTop;
			const viewBottom = viewTop + tocInner.clientHeight;

			if (itemTop < viewTop || itemBottom > viewBottom) {
				tocInner.scrollTo({
					top: itemTop - tocInner.clientHeight / 2 + selectedItem.offsetHeight / 2,
					behavior: 'smooth'
				});
			}
		};

		const setActiveItem = (nextIndex, options = { scroll: true }) => {
			if (nextIndex < -1) nextIndex = -1;
			if (nextIndex >= tocItems.length) nextIndex = tocItems.length - 1;
			if (nextIndex === selectedIndex) return;

			if (selectedIndex >= 0) tocItems[selectedIndex]?.classList.remove('active');
			selectedIndex = nextIndex;
			if (selectedIndex >= 0) tocItems[selectedIndex]?.classList.add('active');

			if (options.scroll) keepActiveItemVisible();
		};

		const updateActiveFromScroll = () => {
			const y = window.scrollY + getHeaderOffset();
			let nextIndex = -1;

			for (let i = 0; i < headingTops.length; i++) {
				if (headingTops[i] <= y) nextIndex = i;
				else break;
			}

			setActiveItem(nextIndex);
		};

		let ticking = false;
		const handleScroll = () => {
			if (ticking) return;
			ticking = true;

			requestAnimationFrame(() => {
				updateActiveFromScroll();
				ticking = false;
			});
		};

		const scrollToHeading = (index) => {
			const target = tags[index];
			if (!target) return;

			target.scrollIntoView({
				behavior: 'smooth',
				block: 'start'
			});
		};

		tocInner.addEventListener('click', (e) => {
			const link = e.target instanceof Element ? e.target.closest('.tocLink') : null;
			if (!(link instanceof HTMLAnchorElement)) return;

			e.preventDefault();

			const index = Number(link.dataset.index);
			if (Number.isNaN(index)) return;

			setActiveItem(index, { scroll: true });
			scrollToHeading(index);

			history.replaceState(null, '', link.getAttribute('href') || '#');
		});

		const handleResize = () => {
			measureHeadingTops();
			updateActiveFromScroll();
		};

		window.addEventListener('scroll', handleScroll, { passive: true });
		window.addEventListener('resize', handleResize);
		window.addEventListener('load', handleResize);

		measureHeadingTops();
		updateActiveFromScroll();
	})();
</script>
