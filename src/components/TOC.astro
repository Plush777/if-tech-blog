---
/* pages > posts > [...slug].astro에서 가져온 headings */
const { headings } = Astro.props;
---

<aside id="toc" class="sticky top-[95px] z-[100] max-[1300px]:hidden" aria-label="목차">
	<div class="tocInner">
		<ul class="flex flex-col">
			{
				headings?.map((h) => (
					<li class={`!leading-[18px] mb-4 text-sm tocDepth${h.depth}`}>
						<a class="tocLink" href={`#${h.slug}`} title={h.text}>
							{h.text}
						</a>
					</li>
				))
			}
		</ul>
	</div>
</aside>

<script>
	// @ts-nocheck
	const articleInner = document.querySelector('.articleInner');
	const tocInner = document.querySelector('.tocInner');

	if (articleInner && tocInner) {
		const ACTIVATION_MARGIN = 2;
		const tags = Array.from(articleInner.querySelectorAll('h2, h3, h4'));
		const tocItems = Array.from(tocInner.querySelectorAll('.tocLink'));
		const header = document.querySelector('#header');

		tags.forEach((heading) => heading.classList.add('heading'));
		tocItems.forEach((item, index) => (item.dataset.index = String(index)));

		let selectedIndex = -1;

		const getActivationY = () => {
			if (!header) return 0;
			return header.getBoundingClientRect().bottom + ACTIVATION_MARGIN;
		};

		const keepActiveItemVisible = () => {
			if (selectedIndex < 0) return;

			const selectedItem = tocItems[selectedIndex];
			if (!selectedItem) return;

			const itemTop = selectedItem.offsetTop;
			const itemBottom = itemTop + selectedItem.offsetHeight;
			const viewTop = tocInner.scrollTop;
			const viewBottom = viewTop + tocInner.clientHeight;

			if (itemTop < viewTop || itemBottom > viewBottom) {
				tocInner.scrollTo({
					top: itemTop - tocInner.clientHeight / 2 + selectedItem.offsetHeight,
					behavior: 'smooth',
				});
			}
		};

		const setActiveItem = (nextIndex, options = { scroll: true }) => {
			if (nextIndex < -1 || nextIndex >= tocItems.length || nextIndex === selectedIndex) return;

			tocItems[selectedIndex]?.classList.remove('active');
			selectedIndex = nextIndex;
			tocItems[selectedIndex]?.classList.add('active');

			if (options.scroll) {
				keepActiveItemVisible();
			}
		};

		const updateActiveFromScroll = () => {
			const activationY = getActivationY();
			let nextIndex = -1;

			tags.forEach((tag, index) => {
				if (tag.getBoundingClientRect().top <= activationY) {
					nextIndex = index;
				}
			});

			setActiveItem(nextIndex);
		};

		let ticking = false;
		const handleScroll = () => {
			if (ticking) return;
			ticking = true;
			requestAnimationFrame(() => {
				updateActiveFromScroll();
				ticking = false;
			});
		};

		const scrollToHeading = (index) => {
			const target = tags[index];
			if (!target) return;

			const top = window.scrollY + target.getBoundingClientRect().top - getActivationY();
			window.scrollTo({ top, behavior: 'smooth' });
		};

		tocInner.addEventListener('click', (e) => {
			const target = e.target;
			if (!(target instanceof HTMLAnchorElement) || !target.matches('.tocLink')) return;

			e.preventDefault();
			const index = Number(target.dataset.index);
			if (Number.isNaN(index)) return;

			scrollToHeading(index);
			history.replaceState(null, '', target.getAttribute('href') || '#');
		});

		window.addEventListener('scroll', handleScroll, { passive: true });
		window.addEventListener('resize', handleScroll);

		updateActiveFromScroll();
	}
</script>
