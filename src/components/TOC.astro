---
/* pages > posts > [...slug].astro에서 가져온 headings */
const { headings } = Astro.props;
---

<aside id="toc" class="sticky top-[95px] z-[100] max-[1300px]:hidden" aria-label="목차">
	<div class="tocInner">
		<ul class="flex flex-col">
			{
				headings?.map((h) => (
					<li class={`!leading-[18px] mb-4 text-sm tocDepth${h.depth}`}>
						<a class="tocLink" href={`#${h.slug}`} title={h.text}>
							{h.text}
						</a>
					</li>
				))
			}
		</ul>
	</div>
</aside>

<script>
	// @ts-nocheck
	// https://stackoverflow.com/questions/55632954/ignore-all-errors-in-a-typescript-file
	const articleInner = document.querySelector('.articleInner');

	if (articleInner) {
		const headings = articleInner.querySelectorAll('h2, h3, h4');

		headings.forEach((heading) => heading.classList.add('heading'));

		const tocInner = document.querySelector('.tocInner');
		const tocItems = document.querySelectorAll('.tocLink');
		const tags = document.querySelectorAll('.heading');
		const header = document.querySelector('#header');
		const SCROLL_GAP = 12;

		tocItems.forEach((item, index) => (item.dataset.index = index));
		tags.forEach((tag, index) => (tag.dataset.index = index));

		let selectedIndex = -1;

		const setActiveItem = (nextIndex) => {
			if (nextIndex < -1 || nextIndex >= tocItems.length || nextIndex === selectedIndex) return;

			tocItems[selectedIndex]?.classList.remove('active');
			selectedIndex = nextIndex;
			tocItems[selectedIndex]?.classList.add('active');
		};

		const getHeaderHeight = () => {
			if (!header) return 0;

			return header.getBoundingClientRect().height;
		};

		const getGroupedActiveIndex = (index) => {
			if (index < 0) return -1;

			let nextIndex = index;

			while (nextIndex > 0 && tocItems[nextIndex - 1]?.title === tocItems[nextIndex]?.title) {
				nextIndex -= 1;
			}

			return nextIndex;
		};

		const updateActiveFromScroll = () => {
			const activationLine = window.scrollY + getHeaderHeight();
			let nextIndex = -1;

			tags.forEach((tag, index) => {
				if (tag.offsetTop <= activationLine) {
					nextIndex = index;
				}
			});

			setActiveItem(getGroupedActiveIndex(nextIndex));
		};

		let ticking = false;
		const handleScroll = () => {
			if (ticking) return;
			ticking = true;
			requestAnimationFrame(() => {
				updateActiveFromScroll();
				ticking = false;
			});
		};

		tocInner?.addEventListener('click', (e) => {
			if (e.target.matches('.tocLink')) {
				e.preventDefault();
				const index = Number(e.target.dataset.index);
				const target = tags[index];

				if (!target) return;

				const top = target.offsetTop - getHeaderHeight() - SCROLL_GAP;
				window.scrollTo({ top, behavior: 'smooth' });
				setActiveItem(index);
			}
		});

		window.addEventListener('scroll', handleScroll, { passive: true });
		window.addEventListener('resize', handleScroll);

		updateActiveFromScroll();
	}
</script>
