---
import FormattedDate from './FormattedDate.astro';
import Image from './Image.astro';
import Pagination from './Pagination.astro';
import PaginationSkeleton from './PaginationSkeleton.astro';
import { hasPostAssetFile, resolvePostFilePath } from '../utils/postAssetPath.js';

const { sectionName, data } = Astro.props;
const pageSize = 8;
const totalPages = Math.max(1, Math.ceil(data.length / pageSize));
const pageParamRaw = Astro.url.searchParams.get('page');
const pageParam = Number.parseInt(pageParamRaw ?? '1', 10);
const currentPage = Number.isNaN(pageParam) ? 1 : Math.min(totalPages, Math.max(1, pageParam));
const startIndex = (currentPage - 1) * pageSize;

function hasValidHeroImage(post) {
	return hasPostAssetFile({
		src: post.data.heroImage,
		pubDate: post.data.pubDate,
		category: post.data.category,
		type: 'assets'
	});
}

function getResolvedHeroImage(post) {
	return resolvePostFilePath({
		src: post.data.heroImage,
		pubDate: post.data.pubDate,
		category: post.data.category,
		type: 'assets'
	});
}
---

<script is:inline>
	document.documentElement.classList.add('pagination-pending');
</script>

<section class:list={[sectionName, 'paginatedPostSection']} data-page-size={pageSize}>
	<slot />
	<PaginationSkeleton pageSize={pageSize} totalPages={totalPages} />
	<ul class="myPostList" data-post-list>
		{
			data.map((post, index) => {
				const hasHeroImage = hasValidHeroImage(post);
				const isVisibleInCurrentPage = index >= startIndex && index < startIndex + pageSize;

				return (
					<li
						class="myPostItem"
						data-post-item
						data-post-index={index}
						hidden={!isVisibleInCurrentPage}
					>
						<a href={`/posts/${post.slug}/`} class="myPostLink">
							{hasHeroImage && (
								<div class="myPostTopBox">
									<Image
										className="absolute top-0 left-0 h-full"
										width="768"
										height="400"
										src={getResolvedHeroImage(post)}
										alt={`${post.data.title} 글 썸네일`}
										type="thumbnail"
									/>
								</div>
							)}

							<div class:list={['myPostBottom', !hasHeroImage && 'myPostBottomNoThumb']}>
								<div class="myPostBottomInner">
									<h4 class="myPostTitle">{post.data.title}</h4>
									<p class="myPostDescription">{post.data.description}</p>
								</div>
								<div class="myPostMeta">
									{post.data.author && <span class="myPostAuthor">by {post.data.author}</span>}
									<p class="myPostDate">
										<FormattedDate date={post.data.pubDate} />
									</p>
								</div>
							</div>
						</a>
					</li>
				);
			})
		}
	</ul>

	<Pagination totalPages={totalPages} currentPage={currentPage} />
</section>

<style is:global>
	html.pagination-pending .paginatedPostSection .myPostList,
	html.pagination-pending .paginatedPostSection [data-pagination] {
		display: none;
	}

	html .paginatedPostSection [data-pagination-skeleton] {
		display: none;
	}

	html.pagination-pending .paginatedPostSection [data-pagination-skeleton] {
		display: block;
	}
</style>

<script>
	const isHTMLElement = (element) => element instanceof HTMLElement;
	const currentUrl = new URL(window.location.href);
	const currentPathname = currentUrl.pathname;
	const parsedPage = Number.parseInt(currentUrl.searchParams.get('page') ?? '1', 10);

	const paginatedSections = document.querySelectorAll('.paginatedPostSection');

	const createPageHref = (page) =>
		page === 1 ? currentPathname : `${currentPathname}?page=${page}`;

	const setControlState = (control, { disabled, href }) => {
		if (!isHTMLElement(control)) {
			return;
		}

		control.href = href;
		control.classList.toggle('is-disabled', disabled);
		control.setAttribute('aria-disabled', disabled ? 'true' : 'false');

		if (disabled) {
			control.setAttribute('tabindex', '-1');
		} else {
			control.removeAttribute('tabindex');
		}
	};

	paginatedSections.forEach((section) => {
		if (!isHTMLElement(section)) {
			return;
		}

		const postItems = Array.from(section.querySelectorAll('[data-post-item]')).filter(
			isHTMLElement
		);
		const pageSize = Number(section.dataset.pageSize) || 8;
		const totalPages = Math.max(1, Math.ceil(postItems.length / pageSize));
		const currentPage = Number.isNaN(parsedPage)
			? 1
			: Math.min(totalPages, Math.max(1, parsedPage));

		const startIndex = (currentPage - 1) * pageSize;
		const endIndex = startIndex + pageSize;

		postItems.forEach((postItem, index) => {
			postItem.hidden = index < startIndex || index >= endIndex;
		});

		const pageLinks = Array.from(section.querySelectorAll('[data-page-link]')).filter(
			isHTMLElement
		);
		pageLinks.forEach((pageLink) => {
			const linkPage = Number.parseInt(pageLink.dataset.page ?? '1', 10);
			const normalizedLinkPage = Number.isNaN(linkPage)
				? 1
				: Math.min(totalPages, Math.max(1, linkPage));
			const isCurrentPage = normalizedLinkPage === currentPage;

			pageLink.href = createPageHref(normalizedLinkPage);
			pageLink.classList.toggle('is-active', isCurrentPage);
			pageLink.setAttribute('aria-current', isCurrentPage ? 'page' : 'false');
		});

		const prevControl = section.querySelector('[data-pagination-control="prev"]');
		const nextControl = section.querySelector('[data-pagination-control="next"]');

		setControlState(prevControl, {
			disabled: currentPage === 1,
			href: createPageHref(Math.max(1, currentPage - 1))
		});
		setControlState(nextControl, {
			disabled: currentPage === totalPages,
			href: createPageHref(Math.min(totalPages, currentPage + 1))
		});
	});

	const removePendingState = () => {
		window.setTimeout(() => {
			document.documentElement.classList.remove('pagination-pending');
		}, 1000);
	};

	if (document.readyState === 'complete') {
		removePendingState();
	} else {
		window.addEventListener('load', removePendingState, { once: true });
	}
</script>
