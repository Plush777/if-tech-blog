---
import FormattedDate from './FormattedDate.astro';
import Image from './Image.astro';
import { hasPostAssetFile, resolvePostFilePath } from '../utils/postAssetPath.js';

const { sectionName, data } = Astro.props;
const pageSize = 8;
const totalPages = Math.max(1, Math.ceil(data.length / pageSize));

function hasValidHeroImage(post) {
	return hasPostAssetFile({
		src: post.data.heroImage,
		pubDate: post.data.pubDate,
		category: post.data.category,
		type: 'assets'
	});
}

function getResolvedHeroImage(post) {
	return resolvePostFilePath({
		src: post.data.heroImage,
		pubDate: post.data.pubDate,
		category: post.data.category,
		type: 'assets'
	});
}
---

<section class:list={[sectionName, 'paginatedPostSection']} data-page-size={pageSize}>
	<slot />
	<ul class="myPostList" data-post-list>
		{
			data.map((post, index) => {
				const hasHeroImage = hasValidHeroImage(post);

				return (
					<li class="myPostItem" data-post-item data-post-index={index} hidden={index >= pageSize}>
						<a href={`/posts/${post.slug}/`} class="myPostLink">
							{hasHeroImage && (
								<div class="myPostTopBox">
									<Image
										className="absolute top-0 left-0 h-full"
										width="768"
										height="400"
										src={getResolvedHeroImage(post)}
										alt={`${post.data.title} 글 썸네일`}
										type="thumbnail"
									/>
								</div>
							)}

							<div class:list={['myPostBottom', !hasHeroImage && 'myPostBottomNoThumb']}>
								<div class="myPostBottomInner">
									<h4 class="myPostTitle">{post.data.title}</h4>
									<p class="myPostDescription">{post.data.description}</p>
								</div>
								<div class="myPostMeta">
									{post.data.author && <span class="myPostAuthor">by {post.data.author}</span>}
									<p class="myPostDate">
										<FormattedDate date={post.data.pubDate} />
									</p>
								</div>
							</div>
						</a>
					</li>
				);
			})
		}
	</ul>

	<nav class="postPagination" data-pagination aria-label="포스트 페이지네이션">
		<button type="button" class="paginationButton" data-pagination-first aria-label="첫 페이지로 이동" disabled>
			&lt;&lt;
		</button>
		<button type="button" class="paginationButton" data-pagination-prev aria-label="이전 페이지로 이동" disabled>
			&lt;
		</button>
		<ul class="paginationList" data-pagination-pages>
			{
				Array.from({ length: totalPages }, (_, index) => index + 1).map((page) => (
					<li>
						<button
							type="button"
							class:list={['paginationButton', page === 1 && 'is-active']}
							data-pagination-page={String(page)}
							aria-label={`${page}페이지로 이동`}
							aria-current={page === 1 ? 'page' : 'false'}
						>
							{page}
						</button>
					</li>
				))
			}
		</ul>
		<button type="button" class="paginationButton" data-pagination-next aria-label="다음 페이지로 이동" disabled={totalPages === 1}>
			&gt;
		</button>
		<button type="button" class="paginationButton" data-pagination-last aria-label="마지막 페이지로 이동" disabled={totalPages === 1}>
			&gt;&gt;
		</button>
	</nav>
</section>

<script>
	const paginatedSections = document.querySelectorAll('.paginatedPostSection');

	paginatedSections.forEach((section, sectionIndex) => {
		const postItems = Array.from(section.querySelectorAll('[data-post-item]'));
		const pageSize = Number(section.dataset.pageSize) || 8;
		const totalPages = Math.max(1, Math.ceil(postItems.length / pageSize));

		const firstButton = section.querySelector('[data-pagination-first]');
		const prevButton = section.querySelector('[data-pagination-prev]');
		const nextButton = section.querySelector('[data-pagination-next]');
		const lastButton = section.querySelector('[data-pagination-last]');
		const pagesContainer = section.querySelector('[data-pagination-pages]');

		if (!firstButton || !prevButton || !nextButton || !lastButton || !pagesContainer) {
			return;
		}

		const storageKey = `post-pagination:${location.pathname}:${sectionIndex}`;
		const storedPage = Number(window.sessionStorage.getItem(storageKey));
		let currentPage = Number.isInteger(storedPage)
			? Math.min(totalPages, Math.max(1, storedPage))
			: 1;

		const updatePagination = () => {
			const startIndex = (currentPage - 1) * pageSize;
			const endIndex = startIndex + pageSize;

			postItems.forEach((postItem, index) => {
				postItem.hidden = index < startIndex || index >= endIndex;
			});

			const pageButtons = pagesContainer.querySelectorAll('[data-pagination-page]');
			pageButtons.forEach((button) => {
				const isCurrentPage = Number(button.dataset.paginationPage) === currentPage;
				button.classList.toggle('is-active', isCurrentPage);
				button.setAttribute('aria-current', isCurrentPage ? 'page' : 'false');
			});

			firstButton.disabled = currentPage === 1;
			prevButton.disabled = currentPage === 1;
			nextButton.disabled = currentPage === totalPages;
			lastButton.disabled = currentPage === totalPages;

			window.sessionStorage.setItem(storageKey, String(currentPage));
		};

		const moveToPage = (page) => {
			currentPage = Math.min(totalPages, Math.max(1, page));
			updatePagination();
		};

		pagesContainer.querySelectorAll('[data-pagination-page]').forEach((button) => {
			button.addEventListener('click', () => {
				moveToPage(Number(button.dataset.paginationPage));
			});
		});

		firstButton.addEventListener('click', () => {
			moveToPage(1);
		});

		prevButton.addEventListener('click', () => {
			moveToPage(currentPage - 1);
		});

		nextButton.addEventListener('click', () => {
			moveToPage(currentPage + 1);
		});

		lastButton.addEventListener('click', () => {
			moveToPage(totalPages);
		});

		updatePagination();
	});
</script>
